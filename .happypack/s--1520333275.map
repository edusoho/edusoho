{"version":3,"sources":["node_modules/.0.14.8@react/lib/EventPropagators.js"],"names":["EventConstants","require","EventPluginHub","warning","accumulateInto","forEachAccumulated","PropagationPhases","getListener","listenerAtPhase","id","event","propagationPhase","registrationName","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","domID","upwards","process","env","NODE_ENV","undefined","phase","bubbled","captured","listener","_dispatchListeners","_dispatchIDs","accumulateTwoPhaseDispatchesSingle","injection","getInstanceHandle","traverseTwoPhase","dispatchMarker","accumulateTwoPhaseDispatchesSingleSkipTarget","traverseTwoPhaseSkipTarget","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateEnterLeaveDispatches","leave","enter","fromID","toID","traverseEnterLeave","accumulateDirectDispatches","EventPropagators","module","exports"],"mappings":"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","file":"EventPropagators.js","sourceRoot":"/Users/kz/projects/edusoho","sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPropagators\n */\n\n'use strict';\n\nvar EventConstants = require('./EventConstants');\nvar EventPluginHub = require('./EventPluginHub');\n\nvar warning = require('fbjs/lib/warning');\n\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\n\nvar PropagationPhases = EventConstants.PropagationPhases;\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(id, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(id, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(domID, upwards, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;\n  }\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(domID, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(id, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(id, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event.dispatchMarker, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {\n  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;"]}