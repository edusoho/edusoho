{"version":3,"sources":["node_modules/.0.14.8@react/lib/ReactUpdates.js"],"names":["CallbackQueue","require","PooledClass","ReactPerf","ReactReconciler","Transaction","assign","invariant","dirtyComponents","asapCallbackQueue","getPooled","asapEnqueued","batchingStrategy","ensureInjected","ReactUpdates","ReactReconcileTransaction","process","env","NODE_ENV","undefined","NESTED_UPDATES","initialize","dirtyComponentsLength","length","close","splice","flushBatchedUpdates","UPDATE_QUEUEING","callbackQueue","reset","notifyAll","TRANSACTION_WRAPPERS","ReactUpdatesFlushTransaction","reinitializeTransaction","reconcileTransaction","prototype","Mixin","getTransactionWrappers","destructor","release","perform","method","scope","a","call","addPoolingTo","batchedUpdates","callback","b","c","d","e","mountOrderComparator","c1","c2","_mountOrder","runBatchedUpdates","transaction","len","sort","i","component","callbacks","_pendingCallbacks","performUpdateIfNecessary","j","enqueue","getPublicInstance","queue","measure","enqueueUpdate","isBatchingUpdates","push","asap","context","ReactUpdatesInjection","injectReconcileTransaction","ReconcileTransaction","injectBatchingStrategy","_batchingStrategy","injection","module","exports"],"mappings":"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","file":"ReactUpdates.js","sourceRoot":"/Users/kz/projects/edusoho","sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n'use strict';\n\nvar CallbackQueue = require('./CallbackQueue');\nvar PooledClass = require('./PooledClass');\nvar ReactPerf = require('./ReactPerf');\nvar ReactReconciler = require('./ReactReconciler');\nvar Transaction = require('./Transaction');\n\nvar assign = require('./Object.assign');\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);\n}\n\nassign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\nflushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;"]}